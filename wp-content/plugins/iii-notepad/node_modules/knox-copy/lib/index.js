// Generated by CoffeeScript 1.4.0
(function() {
  var KeyStream, Parser, ensureBuffer, guzzle, isArray, knox, qs, stripLeadingSlash, swapPrefix, waterfall, workOffStream;

  qs = require('querystring');

  isArray = require('util').isArray;

  waterfall = require('async').waterfall;

  knox = require('knox');

  Parser = require('xml2js').Parser;

  KeyStream = require('./key_stream');

  stripLeadingSlash = function(key) {
    return key.replace(/^\//, '');
  };

  swapPrefix = function(key, oldPre, newPre) {
    return "" + newPre + "/" + (stripLeadingSlash(key.slice(oldPre.length)));
  };

  ensureBuffer = function(data) {
    return Buffer.isBuffer(data) && data || new Buffer(data);
  };

  /*
  Read a whole stream into a buffer.
  */


  guzzle = function(stream, cb) {
    var buffers;
    buffers = [];
    stream.on('data', function(chunk) {
      return buffers.push(ensureBuffer(chunk));
    });
    stream.on('error', function(err) {
      return cb(err);
    });
    return stream.on('end', function() {
      return cb(null, Buffer.concat(buffers));
    });
  };

  /*
  Returns an http request.  Optional callback receives the response.
  */


  knox.prototype.copyFromBucket = function(fromBucket, fromKey, toKey, headers, cb) {
    var req;
    if (typeof headers === 'function') {
      cb = headers;
      headers = {};
    }
    headers['x-amz-copy-source'] = "/" + fromBucket + "/" + (stripLeadingSlash(fromKey));
    headers['Content-Length'] = 0;
    req = this.request('PUT', toKey, headers);
    if (cb != null) {
      req.on('response', function(res) {
        return cb(null, res);
      });
      req.on('error', function(err) {
        return cb(new Error("Error copying " + fromKey + ":", err));
      });
      req.end();
    }
    return req;
  };

  /*
  Callback gets a JSON representation of a page of S3 Object keys.
  */


  knox.prototype.listPageOfKeys = function(_arg, cb) {
    var error, headers, marker, maxKeys, prefix,
      _this = this;
    maxKeys = _arg.maxKeys, marker = _arg.marker, prefix = _arg.prefix, headers = _arg.headers;
    if (maxKeys == null) {
      maxKeys = 1000;
    }
    if (headers == null) {
      headers = {};
    }
    if (prefix != null) {
      prefix = stripLeadingSlash(prefix);
    }
    if (marker != null) {
      marker = stripLeadingSlash(marker);
    }
    error = function(err) {
      return cb(new Error("Error listing bucket " + {
        marker: marker,
        prefix: prefix
      } + ":", err));
    };
    return waterfall([
      function(next) {
        var req;
        req = _this.request('GET', '/', headers);
        req.path += "?" + qs.stringify({
          'max-keys': maxKeys,
          prefix: prefix,
          marker: marker
        });
        req.on('error', error);
        req.on('response', function(res) {
          if (res.statusCode === 200) {
            return guzzle(res, next);
          } else {
            return error(res);
          }
        });
        return req.end();
      }, (new Parser({
        explicitArray: false,
        explicitRoot: false
      })).parseString, function(page, next) {
        page.IsTruncated = page.IsTruncated === 'true';
        page.Contents = isArray(page.Contents) ? page.Contents : page.Contents != null ? [page.Contents] : [];
        return next(null, page);
      }
    ], function(err, page) {
      if (err != null) {
        return error(err);
      } else {
        return cb(null, page);
      }
    });
  };

  knox.prototype.streamKeys = function(_arg) {
    var prefix;
    prefix = _arg.prefix;
    return new KeyStream({
      prefix: prefix,
      client: this
    });
  };

  workOffStream = function(_arg) {
    var concurrency, done, ended, stream, worker, workerCount;
    stream = _arg.stream, concurrency = _arg.concurrency, worker = _arg.worker, done = _arg.done;
    ended = false;
    workerCount = 0;
    if (done == null) {
      done = function() {};
    }
    stream.on('end', function() {
      ended = true;
      if (workerCount === 0) {
        return done();
      }
    });
    return stream.on('data', function(data) {
      if (++workerCount > concurrency) {
        stream.pause();
      }
      return worker(data, function() {
        --workerCount;
        if (ended && workerCount === 0) {
          return done();
        } else {
          return stream.resume();
        }
      });
    });
  };

  knox.prototype.copyBucket = function(_arg, cb) {
    var count, fail, failed, fromBucket, fromClient, fromPrefix, keyStream, toPrefix,
      _this = this;
    fromBucket = _arg.fromBucket, fromPrefix = _arg.fromPrefix, toPrefix = _arg.toPrefix;
    if (fromBucket == null) {
      fromBucket = this.bucket;
    }
    fromClient = knox.createClient({
      key: this.key,
      secret: this.secret,
      bucket: fromBucket
    });
    fromPrefix = fromPrefix && stripLeadingSlash(fromPrefix) || '';
    toPrefix = toPrefix && stripLeadingSlash(toPrefix) || '';
    count = 0;
    failed = false;
    fail = function(err) {
      if (failed) {
        return;
      }
      failed = true;
      return cb(err, count);
    };
    keyStream = fromClient.streamKeys({
      prefix: fromPrefix
    });
    keyStream.on('error', fail);
    return workOffStream({
      stream: keyStream,
      concurrency: 5,
      worker: function(key, done) {
        var toKey;
        toKey = swapPrefix(key, fromPrefix, toPrefix);
        return _this.copyFromBucket(fromBucket, key, toKey, function(err, res) {
          if (err != null) {
            fail(err);
          } else if (res.statusCode !== 200) {
            fail(new Error("" + res.statusCode + " response copying key " + key));
          } else {
            count++;
          }
          return done();
        });
      },
      done: function() {
        if (!failed) {
          return cb(null, count);
        }
      }
    });
  };

  module.exports = knox;

}).call(this);
